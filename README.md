# BokkyPooBahs Red-Black Tree Library

Status: **Work in progress. Documenting before getting further testing and review - don't use yet**

A gas-efficient Solidity library using the Red-Black binary search tree algorithm to help you maintain a sorted `uint` key index for your data. Insertions, deletions and searches are in **O(log n)** time (and ~gas). Note that the value of 0 is prohibited. Use the sorted keys as indices to your mapping tables of data to access your data in sorted order.

<br />

<hr />

### Binary Search Tree

The [Red-Black Tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) binary search tree is a self-rebalancing [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree). Following is a diagram of a binary search tree.

<kbd><img src="https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg" /></kbd>

The binary search tree provides easy access to the *first*, *previous*, *next* and *last* elements.

<br />

### Red-Black Binary Search Tree

The regular binary search tree can become unbalanced. Inserting the keys into the binary search tree in sequential order will result in the tree resembling a linked-list.

The red-black algorithm maintains a red or black colouring for each node in the tree. And from [Wikipedia](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree):

> In addition to the requirements imposed on a binary search tree the following must be satisfied by a red–black tree:
>
> * Each node is either red or black.
> * The root is black. This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice versa, this rule has little effect on analysis.
> * All leaves (NIL) are black.
> * If a node is red, then both its children are black.
> * Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes.

When an element is inserted into or removed from a red-black tree, the binary search tree is rebalanced to satisfy the red-black rules.

From Wikipedia's [Red-Black Tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) page, the following Red-Black tree was created by inserting the items `[13,8,17,11,15,22,25,27,1,6]`:

<kbd><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_example.svg" /></kbd>

<br />

### Red-Black Tree With Random Insertion

The following red-black tree was generated by inserting the numbers 1 to 32 in random order `[15,14,20,3,7,10,11,16,18,2,4,5,8,19,1,9,12,6,17,13]`:

<kbd><img src="docs/RedBlackTree1To32Random.png" /></kbd>

<br />

### Binary Search Tree With Sequential Insertion

The following binary search tree was generated by inserting the numbers 1 to 32 in sequential order `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]`, with the red-black rebalancing algorithm switched off:

<kbd><img src="docs/RedBlackTree1To32SequentialNoRebalance.png" /></kbd>

<br />

### Red-Black Tree With Sequential Insertion

The following red-black tree was generated by inserting the numbers 1 to 32 in sequential order `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]`:

<kbd><img src="docs/RedBlackTree1To32Sequential.png" /></kbd>

<br />

A property of the red-black tree is that the path from the root to the farthest leaf is no more than twice as long as the path from the root to the nearest leaf. The shortest path has all black nodes and the longest path alternate between red and black nodes.

This library uses an iterative (rather than recursive) red-black tree algorithm to maintain the sorted keys.

<br />

### Use Case

An important use-case for this library is to maintain a sorted on-chain order book in decentralised exchange smart contracts.


The root node of the tree is 18, `k` represents the key numbers, `p` the parent, `l` the left node, `r` the right node, and the red-black colouring of each node is used to maintain the tree balance. Nodes with `l0 r0` are the leaves of the tree:

<br />

<hr />

If you find this library useful for your project, **especially commercial projects**, please donate to [0xb6dAC2C5A0222f6794265249ACE15568B750c2d1](https://etherscan.io/address/0xb6dAC2C5A0222f6794265249ACE15568B750c2d1). I hope to cover my cost of getting this library independently audited.


<br />

<hr />

## Table Of Contents

* [History](#history)
* [Deployment](#deployment)
* [Questions And Answers](#questions-and-answers)
* [Functions](#functions)
  * [insert](#insert)
  * [remove](#remove)
* [Algorithm](#algorithm)
* [Gas Cost](#gas-cost)
* [Testing](#testing)
* [References](#references)

<br />

<hr />

## History

<br />

<hr />

## Deployment

This library has been designed to be automatically compiled into your Ethereum Solidity contract or library, instead of having to deploy this library and then linking your contract or library to this library.

<br />

<hr />

## Questions And Answers

<br />

<hr />

## Functions

See [contracts/TestBokkyPooBahsRedBlackTree.sol](contracts/TestBokkyPooBahsRedBlackTree.sol) (or the [flattened](flattened/TestBokkyPooBahsRedBlackTree_flattened.sol) version) for an example contract that uses this library.

### insert

```javascript
function insert(Tree storage self, uint z) internal;
```

<br />

### remove

```javascript
function remove(Tree storage self, uint z) internal;
```

<br />

<hr />

## Algorithm

The main algorithm is listed in [Algorithms for Red Black Tree Operations
(from CLRS text)](http://www.cse.yorku.ca/~aaw/Sotirios/RedBlackTreeAlgorithm.html).

There is one complication with the algorithm above in the function `RB-Delete` in the line `then key[z] := key[y]` replaced with the algorithm in [Iterative Algorithm for Red-Black Tree](https://stackoverflow.com/a/11328289).


<br />

<hr />

## Gas Cost

TODO:

* [ ] Min, Max, Average for 10, 100, 1000, 10000 entries

### Average Case

The following number of items were inserted in random order

The following number of items were inserted in sequential order

Items  | Ins Min | Ins Avg     | Ins Max | Rem Min | Rem Avg    | Rem Max
------:| -------:| -----------:| -------:| -------:| ----------:| -------:
1      | 68459   | 68459       | 68459   | 44835   | 44835      | 44835
5      | 68459   | 99166.2     | 140002  | 30521   | 48024.4    | 74259
10     | 68459   | 118401.5    | 167610  | 30671   | 71973.5    | 119593
50     | 68459   | 124688.32   | 182637  | 30067   | 82894.66   | 213514
100    | 68459   | 123377.19   | 190137  | 30521   | 79761.56   | 191060
500    | 68459   | 124567.396  | 191240  | 30521   | 80108.078  | 261153
1000   | 68459   | 125334.687  | 188278  | 29950   | 81032.364  | 219352
5000   | 68523   | 127270.3138 | 196563  | 30521   | 81972.7506 | 283499
10000  | 68523   | 127210.0136 | 208293  | 30099   | 81485.7675 | 307296
<br />

### Worst Case

The following number of items were inserted in sequential order

Items  | Ins Min | Ins Avg     | Ins Max | Rem Min | Rem Avg    | Rem Max
------:| -------:| -----------:| -------:| -------:| ----------:| -------:
1      | 68459   | 68459       | 68459   | 44835   | 44835      | 44835
5      | 68459   | 107349.4    | 140753  | 29918   | 56072.4    | 86075
10     | 68459   | 116513      | 149588  | 30067   | 75757.2    | 119064
50     | 68459   | 137949.4    | 158598  | 30067   | 86001.76   | 213537
100    | 68459   | 142906.91   | 163103  | 30521   | 87266.18   | 218371
500    | 68459   | 149290.434  | 191089  | 30521   | 86199.74   | 266556
1000   | 68459   | 150802.324  | 208341  | 29950   | 87266.115  | 287889
5000   | 68459   | 153263.3122 | 242846  | 30521   | 88335.6862 | 310295
10000  | 68459   | 154112.5597 | 260099  | 29950   | 88002.9832 | 333443

<br />

<hr />

## Testing

TODO:

* [ ] Test random insertions 10, 1000, 10000
* [ ] Test random insertions and deletions
* [ ] Test repeated random insertions and deletions
* [ ] Test the `view` functions, including what happens when a non-existent key is passed
* [ ] Test deleting a non-existent key
* [ ] Insert duplicate
* [ ] Test adding sequentially increasing and decreasing keys
* [ ] Test whether `nodes[0]` is used now (was used when the algorithm was not quite working correctly)

<br />

<hr />

## References

* [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree).
* Mihail Buricea's *Laboratory Module 6 - Red-Black Trees* at http://software.ucv.ro/~mburicea/lab8ASD.pdf, a copy of which has been saved to [docs/lab8ASD.pdf](docs/lab8ASD.pdf)
* https://stackoverflow.com/questions/3758356/iterative-algorithm-for-red-black-tree

https://stackoverflow.com/a/3759681
-> http://oopweb.com/Algorithms/Documents/Sman/Volume/RedBlackTrees.html
& https://www.epaperpress.com/sortsearch/txt/var.txt
& https://www.epaperpress.com/sortsearch/txt/rbtr.txt
& http://www.cse.yorku.ca/~aaw/Sotirios/RedBlackTreeAlgorithm.html

Also http://read.seas.harvard.edu/~kohler/notes/llrb.html

And https://www.cs.dartmouth.edu/~thc/cs10/lectures/0519/0519.html :
* https://www.cs.dartmouth.edu/~thc/cs10/lectures/0519/RBTree.java

https://www.csee.umbc.edu/courses/undergraduate/341/fall13/section3/lectures/10-Red-Black-Trees.pdf

http://code.activestate.com/recipes/576817-red-black-tree/

http://cseweb.ucsd.edu/~kube/cls/100/Lectures/lec7/lec7.pdf

https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/

<br />

<br />

Thanks to [Solidified](https://solidified.io/) for the 3 minor issues they picked up at the Web3 Summit.


Enjoy!

(c) BokkyPooBah / Bok Consulting Pty Ltd - Oct 16 2018. The MIT Licence.
